---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chs.
--- DateTime: 18-1-7 下午3:03
--- 事件逻辑控制器

require('loader')
require('core.love_engine')
require('gdata.basedata')
require('utils.math_tool')
require('utils.dt_converter')
require('gdata.gamedata')
eventer = {}
math.randomseed(tostring(os.time()):reverse():sub(1, 7))

function eventer.dojob(cur_scene,cur_mouse_x,cur_mouse_y,is_left_click,is_right_click,game_timer)
    --print(cur_scene,cur_mouse_x,cur_mouse_y,is_left_click,is_right_click,game_timer)
    --预先加载地图资源
    if gamedata.is_loaded ==false then
        gamedata.PAN_RUN = basedata.PAN_INIT
        gamedata.is_loaded=true
    end

    if cur_scene == basedata.SCENE_CODE.TITLE.code then
        if  795<cur_mouse_x and cur_mouse_x<880 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.TITLE.is_on_start=true
        elseif  995<cur_mouse_x and cur_mouse_x<1075 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.TITLE.is_on_help=true
        elseif  1195<cur_mouse_x and cur_mouse_x<1270 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.TITLE.is_on_exit=true
        else
            basedata.SCENE_CODE.TITLE.is_on_start=false
            basedata.SCENE_CODE.TITLE.is_on_help=false
            basedata.SCENE_CODE.TITLE.is_on_exit=false
        end

        if basedata.SCENE_CODE.TITLE.is_on_exit and is_left_click then
            --退出游戏
            love_engine.event.quit()
        end
        if basedata.SCENE_CODE.TITLE.is_on_start and is_left_click then
            --重新开始游戏,初始化数据
            loader.SCENE_STATUS.cur_scene=basedata.SCENE_CODE.GAME.code
        end
    end

    if cur_scene == basedata.SCENE_CODE.GAME.code then
        if  795<cur_mouse_x and cur_mouse_x<915 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.GAME.is_on_restart=true
        elseif  995<cur_mouse_x and cur_mouse_x<1075 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.GAME.is_on_help=true
        elseif  1195<cur_mouse_x and cur_mouse_x<1270 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.GAME.is_on_exit=true
        else
            basedata.SCENE_CODE.GAME.is_on_restart=false
            basedata.SCENE_CODE.GAME.is_on_help=false
            basedata.SCENE_CODE.GAME.is_on_exit=false
        end

        if basedata.SCENE_CODE.GAME.is_on_exit and is_left_click then
            --退出游戏
            love_engine.event.quit()
        end
        if basedata.SCENE_CODE.GAME.is_on_restart and is_left_click then
            --重新开始游戏,初始化数据
            gamedata.PAN_RUN = basedata.PAN_INIT
        end

        --如果在执子过程中，则锁定棋子
        if gamedata.is_keepchess == true then
            if is_right_click ==true then
                --右击取消行动
                gamedata.is_keepchess=false
                gamedata.PAN_RUN[gamedata.last_point] = gamedata.last_type
                gamedata.last_point =0
                gamedata.last_type =0
            end
        else
            --如果在选子过程中，则动态选子
            cn = 0
            for i=1,24 do
                if basedata.PAN_XPOINT[i]-45 <cur_mouse_x and cur_mouse_x <basedata.PAN_XPOINT[i]+45 and basedata.PAN_YPOINT[i]-45<cur_mouse_y and cur_mouse_y < basedata.PAN_YPOINT[i]+45 then
                    cn = i
                    break
                end
            end
            gamedata.now_mpoint=cn
            --获取位置
            if gamedata.now_mpoint ~= 0 and gamedata.is_keepchess==false and is_left_click==true and gamedata.PAN_RUN[gamedata.now_mpoint] ~= 0 then

                act_flag = false
                --绘制落子提示
                cr = basedata.ROUTE[gamedata.now_mpoint]
                crl = math_tool.table_leng(cr)
                --确认当前子是否可行动
                for s=1,crl do
                    if gamedata.PAN_RUN[cr[s]] ==0 then
                        act_flag = true
                        break
                    end
                end
                --可行动则提子
                if act_flag==true then
                    gamedata.is_keepchess=true
                    gamedata.last_point = gamedata.now_mpoint
                    --子提起，位置为无子态
                    gamedata.last_type = gamedata.PAN_RUN[gamedata.last_point]
                    gamedata.PAN_RUN[gamedata.last_point] =0
                else
                    gamedata.error_point = gamedata.now_mpoint
                    gamedata.last_error_time=game_timer
                end
            end

            --清空错误状态
            if game_timer-gamedata.last_error_time>1 then
                gamedata.error_point = 0
            end
        end
    end
end
