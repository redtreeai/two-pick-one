---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chs.
--- DateTime: 18-1-7 下午3:03
--- 事件逻辑控制器

require('loader')
require('core.love_engine')
require('gdata.basedata')
require('utils.math_tool')
require('utils.dt_converter')
require('gdata.gamedata')
eventer = {}
math.randomseed(tostring(os.time()):reverse():sub(1, 7))

function eventer.dojob(cur_scene,cur_mouse_x,cur_mouse_y,is_left_click,is_right_click,game_timer)
    --print(cur_scene,cur_mouse_x,cur_mouse_y,is_left_click,is_right_click,game_timer)
    --预先加载地图资源
    if gamedata.is_loaded ==false then
        gamedata.PAN_RUN = basedata.PAN_INIT
        gamedata.is_loaded=true
    end

    if cur_scene == basedata.SCENE_CODE.TITLE.code then
        if  795<cur_mouse_x and cur_mouse_x<880 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.TITLE.is_on_start=true
        elseif  995<cur_mouse_x and cur_mouse_x<1075 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.TITLE.is_on_help=true
        elseif  1195<cur_mouse_x and cur_mouse_x<1270 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.TITLE.is_on_exit=true
        else
            basedata.SCENE_CODE.TITLE.is_on_start=false
            basedata.SCENE_CODE.TITLE.is_on_help=false
            basedata.SCENE_CODE.TITLE.is_on_exit=false
        end

        if basedata.SCENE_CODE.TITLE.is_on_exit and is_left_click then
            --退出游戏
            love_engine.event.quit()
        end
        if basedata.SCENE_CODE.TITLE.is_on_start and is_left_click then
            --开始游戏,进入游戏场景
            loader.SCENE_STATUS.cur_scene=basedata.SCENE_CODE.GAME.code
        end
    end

    if cur_scene == basedata.SCENE_CODE.GAME.code then
        if  795<cur_mouse_x and cur_mouse_x<915 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.GAME.is_on_restart=true
        elseif  995<cur_mouse_x and cur_mouse_x<1075 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.GAME.is_on_help=true
        elseif  1195<cur_mouse_x and cur_mouse_x<1270 and 20<cur_mouse_y and cur_mouse_y<65 then
            basedata.SCENE_CODE.GAME.is_on_exit=true
        else
            basedata.SCENE_CODE.GAME.is_on_restart=false
            basedata.SCENE_CODE.GAME.is_on_help=false
            basedata.SCENE_CODE.GAME.is_on_exit=false
        end

        if basedata.SCENE_CODE.GAME.is_on_exit and is_left_click then
            --退出游戏
            love_engine.event.quit()
        end
        if basedata.SCENE_CODE.GAME.is_on_restart and is_left_click then
            --重新开始游戏,初始化数据
            gamedata.PAN_RUN = {1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0}
            --获胜者 0平局 1玩家1 2玩家2
            gamedata.winner = 0
            --轮次
            gamedata.turn = 1
            --是否执子
            gamedata.is_keepchess = false
            --当前鼠标子位
            gamedata.now_mpoint = 0
            --当前执子的原始位置
            gamedata.last_point = 0
            --当前执子
            gamedata.last_type = 0
            --错误执子位置
            gamedata.error_point = 0
            --上次错误时间点纪录，仅提示一秒
            gamedata.last_error_time = 0
            --吃子位置群
            gamedata.destroy_point_list = {}
            --吃子时间点纪录，仅提示一秒
            gamedata.destroy_time = 0
            --gameover
            basedata.SCENE_CODE.GAME.is_gameover=false
        end

        --棋盘落子坐标的动态定位
        cn = 0
        for i=1,24 do
            if basedata.PAN_XPOINT[i]-45 <cur_mouse_x and cur_mouse_x <basedata.PAN_XPOINT[i]+45 and basedata.PAN_YPOINT[i]-45<cur_mouse_y and cur_mouse_y < basedata.PAN_YPOINT[i]+45 then
                cn = i
                break
            end
        end
        gamedata.now_mpoint=cn

        --如果在执子过程中，则锁定棋子
        if gamedata.is_keepchess == true then
            if is_right_click ==true then
                --右击取消行动
                gamedata.is_keepchess=false
                gamedata.PAN_RUN[gamedata.last_point] = gamedata.last_type
                gamedata.last_point =0
                gamedata.last_type =0
            end
            --如未取消，准备判断落子状态 (1、 为棋盘24落子点之一  2、为直线上的点 3目标点无被占位 4非原点)
            if gamedata.now_mpoint ~= 0 and is_left_click==true and gamedata.PAN_RUN[gamedata.now_mpoint] == 0 and gamedata.now_mpoint~=gamedata.last_point then
                cr = basedata.ROUTE[gamedata.last_point]
                if math_tool.IsInTable(gamedata.now_mpoint,cr)==true and gamedata.PAN_RUN[gamedata.now_mpoint] ==0 then
                    --可行动则落子
                    gamedata.is_keepchess=false
                    gamedata.PAN_RUN[gamedata.now_mpoint] =gamedata.last_type
                    gamedata.last_point =0
                    gamedata.last_type =0
                    --落子后要结算结果
                    dlist = {}
                    for sb=1,24 do
                        --根据规则结算
                        cr = basedata.ROUTE[sb]
                        crl = math_tool.table_leng(cr)
                        if gamedata.PAN_RUN[sb]==1 and gamedata.turn==2 then
                            for a=1,crl do
                                if math.fmod( a, 2)==1 and gamedata.PAN_RUN[cr[a]]==2 and gamedata.PAN_RUN[cr[a+1]]==2 then
                                    table.insert(dlist,sb)
                                end
                            end
                        end
                        if gamedata.PAN_RUN[sb]==2 and gamedata.turn==1 then
                            for a=1,crl do
                                if math.fmod( a, 2)==1 and gamedata.PAN_RUN[cr[a]]==1 and gamedata.PAN_RUN[cr[a+1]]==1 then
                                    table.insert(dlist,sb)
                                end
                            end
                        end
                    end
                    --判断是否有吃子行为
                    if math_tool.table_leng(dlist) ==0 then
                        --donothing
                    else
                        dlistl = math_tool.table_leng(dlist)
                        --清除吃子位
                        for xb=1,dlistl do
                            gamedata.PAN_RUN[dlist[xb]]=0
                        end
                        gamedata.destroy_point_list = dlist
                        gamedata.destroy_time =game_timer
                    end

                    --落子成功且结算成功后交换轮次
                    if gamedata.turn==1 then
                        gamedata.turn=2
                    elseif gamedata.turn==2 then
                        gamedata.turn=1
                    end

                else
                    --不可落子则进行错误提示
                    gamedata.error_point =gamedata.now_mpoint
                    gamedata.last_error_time=game_timer
                end
            end
        else
            --获取位置
            if gamedata.now_mpoint ~= 0 and gamedata.is_keepchess==false and is_left_click==true and gamedata.PAN_RUN[gamedata.now_mpoint] ~= 0 then

                act_flag = false
                cr = basedata.ROUTE[gamedata.now_mpoint]
                crl = math_tool.table_leng(cr)
                --确认当前子是否可行动
                for s=1,crl do
                    if gamedata.PAN_RUN[cr[s]] ==0 then
                        act_flag = true
                        break
                    end
                end
                --确认是否是当前玩家的棋子
                if gamedata.PAN_RUN[gamedata.now_mpoint]==gamedata.turn then
                    --donothing
                else
                    act_flag=false
                end

                --可行动则提子
                if act_flag==true then
                    gamedata.is_keepchess=true
                    gamedata.last_point = gamedata.now_mpoint
                    --子提起，位置为无子态
                    gamedata.last_type = gamedata.PAN_RUN[gamedata.last_point]
                    gamedata.PAN_RUN[gamedata.last_point] =0
                else
                    gamedata.error_point = gamedata.now_mpoint
                    gamedata.last_error_time=game_timer
                end
            end

            --清空错误状态
            if game_timer-gamedata.last_error_time>1 then
                gamedata.error_point = 0
            end

            --清空吃子爆炸状态
            if game_timer-gamedata.destroy_time>1 then
                gamedata.destroy_point_list = {}
            end

            --判断输赢
            cta = 0
            ctb = 0
            for w =1,24 do
                if gamedata.PAN_RUN[w] ==1 then
                    cta = cta+1
                elseif gamedata.PAN_RUN[w] ==2 then
                    ctb = ctb+1
                end
            end
            if cta <2 then
                basedata.SCENE_CODE.GAME.is_gameover=true
                gamedata.winner=2
            elseif ctb <2 then
                basedata.SCENE_CODE.GAME.is_gameover=true
                gamedata.winner=1
            end
        end
    end
end
